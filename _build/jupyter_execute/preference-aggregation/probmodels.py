# Probability Models

To generate profiles, we use the [Preflib.org](https://preflib.org) tools available at [https://github.com/PrefLib/PrefLib-Tools](https://github.com/PrefLib/PrefLib-Tools).   


## Impartial (Anonymous) Culture

1. IC: Impartial Culture Model - generate a profile by sampling  from a uniform distribution over profiles with $n$ candidates and $m$ voters. 

2. IAC: Impartial Anonymous Culture Model - generate a profile by sampling  from a uniform distribution over *anonymous* profiles with $n$ candidates and $m$ voters. 

3. INAC: Impartial Anonymous and Neutral Culture Model<br/>
    O. Egecioglu and A. Giritligil (2013). [The Impartial, Anonymous, and Neutral Culture Model: A Probability Model for Sampling Public Preference Structures](https://sites.cs.ucsb.edu/~omer/DOWNLOADABLE/GMAS_public_preference13.pdf), Journal of Mathematical Sociology, 37: pp. 203 - 222

# import the Profile class
from voting.profiles import Profile
from voting.generate_profiles import *
from voting.voting_methods import *
import networkx as nx
from itertools import combinations
import matplotlib.pyplot as plt
import pickle
import random

from tqdm.notebook import tqdm

pm="IC"
num_trials = 1000
num_candidates = 5
num_voters = 1001

num_condorcet_winner = 0
num_cycles = 0
for t in range(num_trials): 
    prof = generate_profile(num_candidates, num_voters, probmod = pm)
    num_condorcet_winner += prof.condorcet_winner() is not None
    num_cycles += has_cycle(prof.margin_graph())
    
print(f"{round(num_condorcet_winner / num_trials, 2) *100}% of profiles have a Condorcet winner.")
print(f"{round(num_cycles / num_trials, 2) *100}% of profiles have a majority cycle.")

pm="IAC"
num_trials = 1000
num_candidates = 5
num_voters = 1001

num_condorcet_winner = 0
num_cycles = 0
for t in range(num_trials): 
    prof = generate_profile(num_candidates, num_voters, probmod = pm)
    num_condorcet_winner += prof.condorcet_winner() is not None
    num_cycles += has_cycle(prof.margin_graph())
print(f"{round(num_condorcet_winner / num_trials, 2) *100}% of profiles have a Condorcet winner.")
print(f"{round(num_cycles / num_trials, 2) * 100}% of profiles have a majority cycle.")

%%time 

SKIP_SIMULATION = True

if not SKIP_SIMULATION: 
    all_num_candidates = [3, 4, 5, 6, 10]
    all_num_voters = [10, 11, 100, 101, 1000, 1001]
    num_trials = 25000

    voting_scenarios = list(product(all_num_candidates, all_num_voters))
    data = {vs: 
            {
                "perc_condorcet_winners": {"IC": 0, "IAC": 0},
                "perc_cycles": {"IC": 0, "IAC": 0},            
            } 
            for vs in voting_scenarios
           }

    for nc, nv in tqdm(voting_scenarios): 
        num_condorcet_winner_IC = 0
        num_condorcet_winner_IAC = 0
        num_cycle_IC = 0
        num_cycle_IAC = 0
        for t in range(num_trials): 
            prof_IC = generate_profile(nc, nv, probmod="IC")       
            prof_IAC = generate_profile(nc, nv, probmod="IAC")        

            num_condorcet_winner_IC += prof_IC.condorcet_winner() is not None 
            num_cycle_IC += has_cycle(prof_IC.margin_graph())

            num_condorcet_winner_IAC += prof_IAC.condorcet_winner() is not None 
            num_cycle_IAC += has_cycle(prof_IAC.margin_graph())

        data[(nc, nv)]["perc_condorcet_winners"]["IC"] = num_condorcet_winner_IC /  num_trials
        data[(nc, nv)]["perc_cycles"]["IC"] = num_cycle_IC /  num_trials
        data[(nc, nv)]["perc_condorcet_winners"]["IAC"] = num_condorcet_winner_IAC /  num_trials
        data[(nc, nv)]["perc_cycles"]["IAC"] = num_cycle_IAC /  num_trials

    pickle.dump(data, open("condorcet_data.pkl", "wb"))

import tabulate

if SKIP_SIMULATION: 
    data = pickle.load(open("condorcet_data.pkl", "rb"))
    all_num_candidates = [3, 4, 5, 6, 10]
    all_num_voters = [10, 11, 100, 101, 1000, 1001]

table = list()
headers = list()

for nc in all_num_candidates: 
    row = [nc]
    for nv in all_num_voters: 
        row.append(f"{round(data[(nc, nv)]['perc_condorcet_winners']['IC'],2)}, {round(data[(nc, nv)]['perc_condorcet_winners']['IAC'],2)}")
    table.append(row)
headers = [str(nv) for nv in all_num_voters]
print(tabulate.tabulate(table, headers, tablefmt="github"))
                   

## Urn Model

In the Polya-Eggenberger urn model, each voter in turn randomly draws a linear order from an urn. Initially the urn is $\mathcal{L}(X)$. If a voter randomly chooses $L$ from the urn, we return $L$ to the urn plus $\alpha\in\mathbb{N}$ copies of $L$. 

* IC is the special case where $\alpha=0$. 
* IAC is the special case where $\alpha=1$. 


print("Generated by the URN model with alpha = 0")
prof = generate_profile(4, 5, probmod="URN", probmod_param=0)
prof.display()

print("Generated by the URN model with alpha = 1")
prof = generate_profile(4, 5, probmod="URN", probmod_param=1)
prof.display()

print("Generate by URN model with alpha = 10")
prof = generate_profile(4, 5, probmod="URN", probmod_param=10)
prof.display()

print("Generate by URN model with alpha = 100")
prof = generate_profile(4, 5, probmod="URN", probmod_param=100)
prof.display()

## from preflib tools ###

# Generate votes based on the URN Model..
# we need numvotes with replace replacements.
def gen_urn(numvotes, replace, alts):
    voteMap = {}
    ReplaceVotes  = {}
    
    ICsize = math.factorial(len(alts))
    print("ICsize ", ICsize)
    ReplaceSize = 0

    for x in range(numvotes):
        print("initially  voteMap is", voteMap)
        print("initially ReplaceVotes is", ReplaceVotes)
        flip =  random.randint(1, ICsize+ReplaceSize)
        print("flip:", flip)
        if flip <= ICsize:
            #generate an IC vote and make a suitable number of replacements...
            print("flip less than ICsize, so generate a new ranking")
            tvote = tuple(np.random.permutation(len(alts))) # gen_ic_vote(alts)
            voteMap[tvote] = (voteMap.get(tvote, 0) + 1)
            ReplaceVotes[tvote] = (ReplaceVotes.get(tvote, 0) + replace)
            ReplaceSize += replace
            print("ReplaceSize", ReplaceSize)
            print("made " + str(tvote))
        else:
            print("find the ranking from ReplaceVote ")

            #iterate over replacement hash and select proper vote.
            flip = flip - ICsize
            for vote in ReplaceVotes.keys():
                print("testing ", vote)
                flip = flip - ReplaceVotes[vote]
                print("flip is now", flip)
                if flip <= 0:
                    print("Found the ranking")
                    voteMap[vote] = (voteMap.get(vote, 0) + 1)
                    ReplaceVotes[vote] = (ReplaceVotes.get(vote, 0) + replace)
                    ReplaceSize += replace
                    break
            else:
                print("We Have a problem... replace fell through....")		
                exit()
        print("now, voteMap is", voteMap)
        print("now, ReplaceVotes is", ReplaceVotes)
        print("======\n")
    return voteMap

# Return a TUPLE! IC vote given a vector of alternatives.   

def gen_ic_vote(alts):
    options = list(alts)
    vote  = []
    while(len(options) > 0):
        #randomly select an option
        vote.append(options.pop(random.randint(0,len(options)-1)))
    return tuple(vote)


gen_urn(5,1,[0,1,2,3])

## Mallows Model

In the Mallow's model, given a reference ranking $L_0\in\mathcal{L}(X)$ and $\phi\in (0,1]$, the probability that a voter's ballot is $L\in\mathcal{L}(X)$ is $Pr_{L_0}(L)=\phi^{\tau(L,L_0)}/C$ where $\tau(L,L_0)= {{|X|}\choose{2}} - |L\cap L_0|$, the Kendell-tau distance of $L$ to $L_0$, and $C$ is a normalization constant.   


The **Kendal-tau** distance, also known as the **swap** distance,  between rankings $R_1$ and $R_2$ is the minimal number of swaps of adjacent candidates needed to turn vote $R_1$ into vote $R_2$.


E.g., the rankings $a\ b\ c\ d$  and $a\ d\ b\ c$ has a swap distance of 2. 

IC is the special case where $\phi=1$.  


MALLOWS_2REF: Consider an ordering $L_0$ and its converse $L_0^{-1}$ (e.g., $L_0$ ranks candidates from more liberal to more conservative, and $L_0^{-1}$ vice versa), in which case the probability that a voter's ballot is $L$ is $\frac{1}{2} Pr_{L_0}(L)+\frac{1}{2}Pr_{L_0^{-1}}(L)$. 

import random 

# For Phi and a given number of candidates, compute the
# insertion probability vectors.
def compute_mallows_insertvec_dist(ncand, phi):
    #Compute the Various Mallows Probability Distros
    vec_dist = {}
    for i in range(1, ncand+1):
        #Start with an empty distro of length i
        dist = [0] * i
        #compute the denom = phi^0 + phi^1 + ... phi^(i-1)
        denom = sum([pow(phi,k) for k in range(i)])
        #Fill each element of the distro with phi^i-j / denom
        for j in range(1, i+1):
            dist[j-1] = pow(phi, i - j) / denom
        #print(str(dist) + "total: " + str(sum(dist)))
        vec_dist[i] = dist
    return vec_dist

# Return a value drawn from a particular distribution.
def draw(values, distro):
    #Return a value randomly from a given discrete distribution.
    #This is a bit hacked together -- only need that the distribution
    #sums to 1.0 within 5 digits of rounding.
    if round(sum(distro),5) != 1.0:
        print("Input Distro is not a Distro...")
        print(str(distro) + "  Sum: " + str(sum(distro)))
        exit()
    if len(distro) != len(values):
        print("Values and Distro have different length")

    cv = 0
    draw = random.random() - distro[cv]
    while draw > 0.0:
        cv+= 1
        draw -= distro[cv]
    return values[cv]



# Generate a Mallows model with the various mixing parameters passed in
# nvoters is the number of votes we need
# candmap is a candidate map
# mix is an array such that sum(mix) == 1 and describes the distro over the models
# phis is an array len(phis) = len(mix) = len(refs) that is the phi for the particular model
# refs is an array of dicts that describe the reference ranking for the set.
def gen_mallows(nvoters, candmap, mix, phis, refs):

    if len(mix) != len(phis) or len(phis) != len(refs):
        print("Mix != Phis != Refs")
        exit()

    print("refs is", refs)
    #Precompute the distros for each Phi and Ref.
    #Turn each ref into an order for ease of use...
    m_insert_dists = []
    for i in range(len(mix)):
        m_insert_dists.append(compute_mallows_insertvec_dist(len(candmap), phis[i]))
    print("m_insert_dists", m_insert_dists)
    #Now, generate votes...
    votemap = {}
    for cvoter in range(nvoters):
        cmodel = draw(list(range(len(mix))), mix)
        print("cmodel is ", cmodel)
        #Generate a vote for the selected model
        insvec = [0] * len(candmap)
        for i in range(1, len(insvec)+1):
            #options are 1...max
            print("i is ", i)
            print("Options: " + str(list(range(1, i+1))))
            print("Drawing on model " + str(cmodel))
            print("Dist: " + str(m_insert_dists[cmodel][i]))
            print("range ", list(range(1, i+1)))
            insvec[i-1] = draw(list(range(1, i+1)), m_insert_dists[cmodel][i])
            print("choice is ", insvec[i-1]) 
            print("--\n")
        print("\ninsvec is ", insvec,"\n")
        vote = []
        for i in range(len(refs[cmodel])):
            print("i is ", i)
            print("refs is ", refs[cmodel])
            print("building vote ", refs[cmodel][i])
            #print("building vote insvec[i] - 1", insvec[i]-1)
            vote.insert(insvec[i]-1, refs[cmodel][i])
            print("vote is ", vote)
            print("++++\n")
        print("mallows vote: " + str(vote))
        tvote = tuple(vote)
        
        votemap[tuple(vote)] = votemap.get(tuple(vote), 0) + 1
        print("-------\n")
    return votemap


num_cands = 4
num_voters = 2
phis = [1.0]
cmap = {cn:cn for cn in range(num_cands)}
print(cmap)


print(gen_mallows(num_voters, 
                  cmap, 
                  [1.0], 
                  phis, 
                  [{0:3, 1:1, 2:0, 3:2}]))

print("Generated by the MALLOWS model with phi = 0")
prof = generate_profile(4, 5, probmod="MALLOWS", probmod_param=0)
prof.display()

print("Generated by the MALLOWS model with phi = 0.1")
prof = generate_profile(4, 5, probmod="MALLOWS", probmod_param=0.1)
prof.display()

print("Generated by the MALLOWS model with phi = 0.5")
prof = generate_profile(4, 5, probmod="MALLOWS", probmod_param=0.5)
prof.display()

print("Generated by the MALLOWS model with phi = 0.8")
prof = generate_profile(4, 5, probmod="MALLOWS", probmod_param=0.8)
prof.display()


print("Generated by the MALLOWS model with phi = 1")
prof = generate_profile(4, 5, probmod="MALLOWS", probmod_param=1.0)
prof.display()


## Single Peaked 



# Return a Tuple for a IC-Single Peaked... with alternatives in range 1....range.
def gen_icsp_single_vote(alts):
    a = 0
    b = len(alts)-1
    temp = []
    while a != b:
        print(f"a={a}, b={b}")
        if random.randint(0,1) == 1:
            temp.append(alts[a])
            a+= 1
        else:
            temp.append(alts[b])
            b -= 1
        print("temp is ", temp)
    temp.append(alts[a])
    print(temp)
    print("-----\n")
    return tuple(temp[::-1]) # reverse


def gen_single_peaked_impartial_culture_strict(nvotes, alts):
    voteset = {}
    for i in range(nvotes):
        tvote = gen_icsp_single_vote(alts)
        voteset[tvote] = voteset.get(tvote, 0) + 1
    return voteset




num_cands = 4
num_voters = 1

vs = gen_single_peaked_impartial_culture_strict(num_voters, list(range(num_cands)))

prof = Profile([v[0] for v in vs.items()], num_cands, rcounts = [v[1] for v in vs.items()])
prof.display()

## Spatial Model 

S. Merrill, III (1993). [Voting behavior under the directional spatial model of electoral
competition](https://link.springer.com/article/10.1007/BF01047992), Public Choice 77, pp. 739 - 756.



def voter_utility(v_pos, c_pos, beta):
    '''Based on the Rabinowitz and Macdonald (1989) mixed model
    described in Section 3, pp. 745 - 747 of 
    "Voting behavior under the directional spatial model of electoral competition" by S. Merrill III 
    
    beta = 1 is the proximity model
    beta = 0 is the directional model
    '''
    return 2 * np.dot(v_pos, c_pos) - beta*(np.linalg.norm(v_pos)**2 + np.linalg.norm(c_pos)**2)

def create_prof_spatial_model2(num_voters, cmap, params):
    num_dim = params[0] # the first component of the parameter is the number of dimensions
    beta = params[1] # used to define the mixed model: beta = 1 is proximity model (i.e., Euclidean distance)
    num_cands = len(cmap.keys())  
    mean = [0] * num_dim # mean is 0 for each dimension
    cov = np.diag([1]*num_dim)  # diagonal covariance
    
    # sample candidate/voter positions using a multivariate normal distribution
    cand_positions = np.random.multivariate_normal(np.array(mean), cov, num_cands)
    voter_positions = np.random.multivariate_normal(np.array(mean), cov, num_voters)
    
    # generate the rankings and counts for each ranking
    ranking_counts = dict()
    for v,v_pos in enumerate(voter_positions):
        v_utils = {voter_utility(v_pos,c_pos,beta): c for c,c_pos in enumerate(cand_positions)}
        ranking = tuple([v_utils[_u] for _u in sorted(v_utils.keys(),reverse=True)])
        if ranking in ranking_counts.keys():
            ranking_counts[ranking] += 1
        else:
            ranking_counts.update({ranking:1})
    
    # list of tuples where first component is a ranking and the second is the count
    prof_counts = ranking_counts.items()
    
    return [rc[0] for rc in prof_counts], [rc[1] for rc in prof_counts], list(voter_positions), list(cand_positions)


num_cands = 4

beta = 0.5
dim = 2

rankings,rcounts,voter_positions, cand_positions = create_prof_spatial_model2(10, 
                                                                              {c:c for c in range(num_cands)}, 
                                                                              [dim, beta])
prof = Profile(rankings, num_cands, rcounts=rcounts)

prof.display()

plt.scatter([v[0] for v in voter_positions], [v[1] for v in voter_positions], color='blue', marker='x')

plt.scatter([c[0] for c in cand_positions], [c[1] for c in cand_positions], color='red', marker='o')

for c_idx,c in enumerate(cand_positions):
    print(f"the utility of {c_idx} is {voter_utility(voter_positions[0], c, beta)}")

for c_idx,c in enumerate(cand_positions):
    plt.text(c[0]+0.05, c[1], c_idx)
plt.show()

num_cands = 4
beta = 1.0
dim = 2


rankings,rcounts,voter_positions, cand_positions = create_prof_spatial_model2(10, 
                                                                              {c:c for c in range(num_cands)}, 
                                                                              [dim, beta])


prof = Profile(rankings, num_cands, rcounts=rcounts)

prof.display()


plt.scatter([v[0] for v in voter_positions], [v[1] for v in voter_positions], color='blue', marker='x')

plt.scatter([c[0] for c in cand_positions], [c[1] for c in cand_positions], color='red', marker='o')

plt.scatter([0], [0], color='black', marker='o')

for c_idx,c in enumerate(cand_positions):
    print(f"the utility of {c_idx} is {voter_utility(voter_positions[0], c, beta)}")

    
for c_idx,c in enumerate(cand_positions):
    plt.text(c[0]+0.05, c[1], c_idx)
plt.show()

num_voters = 10
num_cands = 4

e_model = "1d_interval"
#1d_interval
#1d_interval_bis"
#1d_gaussian
#1d_gaussian_bis
#1d_one_sided_triangle
#1d_full_triangle
#1d_two_party 

from mapel.voting import elections

rankings = elections.generate_elections_1d_simple(election_model = e_model, 
                                                  num_voters=num_voters, 
                                                  num_candidates = num_cands)

prof = Profile([tuple(r) for r in rankings], num_cands)
prof.display()


num_voters = 10
num_cands = 4

e_model = "2d_disc"

#2d_disc
#2d_range_disc
#2d_range_overlapping
#2d_square 
#2d_sphere
#2d_gaussian
#2d_range_gaussian 
#2d_range_fourgau 

        
rankings = elections.generate_elections_2d_simple(election_model = e_model, 
                                                  num_voters=num_voters, 
                                                  num_candidates = num_cands)

prof = Profile([tuple(r) for r in rankings], num_cands)
prof.display()


num_voters = 10
num_cands = 4


e_model = "40d_ball"

# 3d_sphere
# 3d_cube
# 3d_ball
# 4d_sphere
# 4d_cube
# 4d_ball
# 5d_sphere
# 5d_cube
# 5d_ball
# 10d_cube
# 15d_cube
# 20d_cube
# 40d_cube
# 40d_ball
   
rankings = elections.generate_elections_nd_simple(election_model = e_model, 
                                                  num_voters=num_voters, 
                                                  num_candidates = num_cands)

prof = Profile([tuple(r) for r in rankings], num_cands)
prof.display()


## Mapping Elections



S. Szufa, P. Piotr Faliszewski, P. Skowron, A. Skinko,  and N. Talmon, [Drawing a Map of Elections in the Space of Statistical Cultures](http://www.ifaamas.org/Proceedings/aamas2020/pdfs/p1341.pdf), AAMAS 2020, Auckland, New Zealand, 


import mapel
import math
mapel.hello()

print()

#mapel.compute_highest_borda("testbed_100_100") 


mapel.print_2d("testbed_100_100")

mapel.print_2d("testbed_100_100", mask=True)

import os
from mapel.voting import objects as obj

def get_highest_borda_score(election):
    scores = [0 for _ in range(election.num_candidates)]
    for vote in election.votes:
        print(vote)
        for i in range(len(vote)):
            scores[vote[i]] += election.num_candidates - i - 1
    return max(scores)


def is_condorect_winner(election):

    for i in range(election.num_candidates):

        condocret_winner = True
        for j in range(election.num_candidates):

            diff = 0
            for k in range(election.num_voters):

                if election.potes[k][i] <= election.potes[k][j]:
                    diff += 1

            if diff < math.ceil((election.num_voters+1)/2.):
                condocret_winner = False
                break

        if condocret_winner:
            return True

    return False


def compute_highest_borda(experiment_id):

    model = obj.Model(experiment_id)
    for i in range(model.num_elections)[0:10]:
        election_id = 'core_' + str(i)
        election = obj.Election(experiment_id, election_id)
        score = get_highest_borda_score(election)
        print(i, score)

        file_name = 'borda_score.txt'
        path = os.path.join(os.getcwd(), 'experiments', experiment_id, 'controllers', 'advanced', file_name)
        with open(path, 'a') as txtfile:
            txtfile.write(str(score) + "\n")

def compute_condorcet_winner(experiment_id):

    model = obj.Model(experiment_id)
    file_name = 'condorcet_score.txt'
    path = os.path.join(os.getcwd(), 'experiments', experiment_id, 'controllers', 'advanced', file_name)
    os.remove(path)
    for i in range(model.num_elections):
        election_id = 'core_' + str(i)
        election = obj.Election(experiment_id, election_id)
        score = float(int(is_condorect_winner(election)))
        print(i, score)

        file_name = 'condorcet_score.txt'
        path = os.path.join(os.getcwd(), 'experiments', experiment_id, 'controllers', 'advanced', file_name)
        with open(path, 'a') as txtfile:
            txtfile.write(str(score) + "\n")

compute_condorcet_winner('testbed_100_100')

mapel.print_2d("testbed_100_100", mask=True)

file_name = 'condorcet_score'
mapel.print_2d('testbed_100_100', values=file_name)


vms = [borda, hare, coombs, plurality_with_runoff, minimax]

def compute_diff_winners(experiment_id):

    file_name = 'diffvms_score.txt'
    path = os.path.join(os.getcwd(), 'experiments', experiment_id, 'controllers', 'advanced', file_name)
    os.remove(path)
    model = obj.Model(experiment_id)
    for i in range(model.num_elections):
        election_id = 'core_' + str(i)
        election = obj.Election(experiment_id, election_id)
        #print(election.votes)
        prof = Profile([tuple(r) for r in election.votes], election.num_candidates)
        num_diff = 0
        for vm in vms: 
            if plurality(prof) != vm(prof): 
                num_diff += 1
        score = float(num_diff) 
        print(i, score)

        file_name = 'diffvms_score.txt'
        path = os.path.join(os.getcwd(), 'experiments', experiment_id, 'controllers', 'advanced', file_name)
        with open(path, 'a') as txtfile:
            txtfile.write(str(score) + "\n")

compute_diff_winners('testbed_100_100')



file_name = 'diffvms_score'
mapel.print_2d('testbed_100_100', values=file_name)



vm = plurality 
def compute_condorcet_eff(experiment_id):

    model = obj.Model(experiment_id)
    file_name = 'condorceteff_score.txt'
    path = os.path.join(os.getcwd(), 'experiments', experiment_id, 'controllers', 'advanced', file_name)
    os.remove(path)

    for i in range(model.num_elections):
        election_id = 'core_' + str(i)
        election = obj.Election(experiment_id, election_id)
        #print(election.votes)
        prof = Profile([tuple(r) for r in election.votes], election.num_candidates)
        cw = prof.condorcet_winner()
        _score = cw is None or [cw] == vm(prof)
        score = float(_score) 
        print(i, score)

        path = os.path.join(os.getcwd(), 'experiments', experiment_id, 'controllers', 'advanced', file_name)
        with open(path, 'a') as txtfile:
            txtfile.write(str(score) + "\n")

compute_condorcet_eff('testbed_100_100')


file_name = 'condorceteff_score'
mapel.print_2d('testbed_100_100', values=file_name, normalizing_func = lambda x: x)


vm = hare 
def compute_size_ws(experiment_id):

    model = obj.Model(experiment_id)
    file_name = 'size_winning_set_score.txt'
    path = os.path.join(os.getcwd(), 'experiments', experiment_id, 'controllers', 'advanced', file_name)
    os.remove(path)

    for i in range(model.num_elections):
        election_id = 'core_' + str(i)
        election = obj.Election(experiment_id, election_id)
        #print(election.votes)
        prof = Profile([tuple(r) for r in election.votes], election.num_candidates)
        cw = prof.condorcet_winner()
        score = float(len(vm(prof))) 
        print(i, score)

        path = os.path.join(os.getcwd(), 'experiments', experiment_id, 'controllers', 'advanced', file_name)
        with open(path, 'a') as txtfile:
            txtfile.write(str(score) + "\n")

compute_size_ws('testbed_100_100')


file_name = 'size_winning_set_score'
mapel.print_2d('testbed_100_100', values=file_name)


## Real Elections

import glob
election_data_directory = './election-data/'


# read the file containing election data and return a profile
def read_election_data(fname):
    with open(fname, 'r') as fp:
        line = fp.readline()
        num_cands = int(line)
        remaining_lines = fp.readlines()
        num_rankings = remaining_lines[num_cands]
        rankings_data = remaining_lines[num_cands + 1:]
        anon_prof = {}
        rankings = list()
        rcounts = list()
        for r in rankings_data:
            _ranking = r.split(',')
            num = int(_ranking[0])
            rankings.append(tuple([int(_.strip()) - 1 for _ in _ranking[1:num_cands+1]]))
            rcounts.append(num)
        
        return Profile(rankings,  num_cands, rcounts = rcounts)



prof = read_election_data(f"{election_data_directory}ED-00025-00000002.soc")

prof.display()

prof.condorcet_winner()

num_elections = 0
num_condorcet_winner = 0
num_cycle = 0
for fname in glob.glob(election_data_directory + "/*.soc"):
    num_elections += 1
    prof = read_election_data(fname)
    print(f"Election {num_elections}")
    print("\tNumber of candidates: ", prof.num_cands)
    print("\tNumber of voters: ", prof.num_voters)
    
    num_condorcet_winner += prof.condorcet_winner() is not None
    num_cycle += has_cycle(prof.margin_graph())
    
print(f"Out of {num_elections} elections:")
print(f"\t{round(num_condorcet_winner / num_elections, 4)*100}% have a Condorcet winner")
print(f"\t{round(num_cycle / num_elections, 4)*100}% have a cycle in the majority graph")



